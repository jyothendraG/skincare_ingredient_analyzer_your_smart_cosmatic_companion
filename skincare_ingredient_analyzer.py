# -*- coding: utf-8 -*-
"""Skincare Ingredient Analyzer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sPb1kvDRPLhYCbrrDeFdRdc6lLdQ-Sfa
"""

!pip install easyocr fuzzywuzzy scikit-learn pandas numpy nltk openpyxl

import easyocr
import re
import pandas as pd
import pickle
import numpy as np
from fuzzywuzzy import fuzz, process
from nltk.corpus import stopwords
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import nltk

# Download stopwords for preprocessing
nltk.download('stopwords')

# Load ingredient analysis dataset
ingredient_csv_path = "/content/ingredientanalyzer.csv"  # Upload this to Colab
recommendation_file_path = "/content/recommendation 1.xlsx"  # Upload this to Colab

# Ingredient Analyzer Class
class IngredientScanner:
    def __init__(self, csv_path, model_path='ingredient_model.sav'):
        self.ingredients = None
        self.csv_data = pd.read_csv(csv_path)
        self.harmful_ingredients = []
        self.warning_ingredients = []
        self.safe_ingredients = []
        self.unidentified_ingredients = []
        self.model_path = model_path

        self.load_or_train_model()

    def load_or_train_model(self):
        try:
            with open(self.model_path, 'rb') as file:
                self.trained_model = pickle.load(file)
                print("Loaded pre-trained ingredient model.")
        except FileNotFoundError:
            print("No pre-trained model found. Using CSV data as reference.")
            self.trained_model = self.csv_data
            with open(self.model_path, 'wb') as file:
                pickle.dump(self.trained_model, file)

    def preprocess(self, text):
        stop_words = set(stopwords.words('english'))
        ingredients_list = []
        for item in text:
            item = item.strip()
            if "ingredients" not in item.lower() and item.lower() not in stop_words:
                ingredients_list.append(item)

        self.ingredients = ', '.join(ingredients_list)

    def convert_image_to_text(self, path):
        reader = easyocr.Reader(['en'])
        result = reader.readtext(path, detail=0)
        print("Extracted text from image:", result)

        cleaned_text = []
        for line in result:
            words = re.findall(r'[^.,:/\()[\n]+', line)
            cleaned_text.extend(words)

        self.preprocess(cleaned_text)

    def analyze(self):
        ingredient_list = [i.strip().lower() for i in self.ingredients.split(', ')]
        for ingredient in ingredient_list:
            match_result = process.extractOne(
                ingredient,
                self.trained_model['name'].str.lower().tolist(),
                scorer=fuzz.ratio
            )
            if match_result:
                match, score = match_result
                if score >= 80:
                    matched_row = self.trained_model[self.trained_model['name'].str.lower() == match]
                    rating = matched_row['rating_num'].values[0]
                    effect = matched_row['effect'].values[0] if 'effect' in matched_row.columns else None
                    if rating == 0:
                        self.harmful_ingredients.append((match, effect))
                    elif rating == 1:
                        self.warning_ingredients.append((match, effect))
                    elif rating in [2, 3]:
                        self.safe_ingredients.append(match)
                else:
                    self.unidentified_ingredients.append(ingredient)

    def report(self):
        print("\nüîç **ANALYSIS REPORT**")
        print(f"**Extracted Ingredients:** {self.ingredients}")

        print("\nüö® **HARMFUL INGREDIENTS:**")
        if self.harmful_ingredients:
            for ing, effect in self.harmful_ingredients:
                effect_info = f" (Effect: {effect})" if effect else ""
                print(f"- {ing}{effect_info}")
        else:
            print("‚úÖ No harmful ingredients found.")

        print("\n‚ö†Ô∏è **WARNING INGREDIENTS:**")
        if self.warning_ingredients:
            for ing, effect in self.warning_ingredients:
                effect_info = f" (Effect: {effect})" if effect else ""
                print(f"- {ing}{effect_info}")
        else:
            print("‚úÖ No warning ingredients found.")

        print("\nüü¢ **SAFE INGREDIENTS:**")
        if self.safe_ingredients:
            print(", ".join(self.safe_ingredients))
        else:
            print("No safe ingredients found.")

        print("\n‚ùì **UNIDENTIFIED INGREDIENTS:**")
        if self.unidentified_ingredients:
            print(f"Total unidentified ingredients: {len(self.unidentified_ingredients)}")
            print(", ".join(self.unidentified_ingredients))
        else:
            print("All ingredients identified.")

# Product Recommendation System
def load_and_train_model(file_path):
    df = pd.read_excel(file_path)
    df = df.applymap(lambda x: x.strip().lower() if isinstance(x, str) else x)

    skin_types = sorted(df["Skin type"].unique())
    concerns = sorted(df["Concern"].astype(str).unique())
    categories = sorted(df["Category"].unique())

    label_encoders = {}
    for col in ["Skin type", "Concern", "Category"]:
        le = LabelEncoder()
        df[col] = le.fit_transform(df[col])
        label_encoders[col] = le

    X = df[["Skin type", "Concern", "Category"]]
    y = df["Product"]

    rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
    rf_model.fit(X, y)

    return rf_model, label_encoders, df, skin_types, concerns, categories

def recommend_products(skin_type, concern, category, rf_model, label_encoders, df):
    try:
        encoded_input = [
            label_encoders['Skin type'].transform([skin_type])[0],
            label_encoders['Concern'].transform([concern])[0],
            label_encoders['Category'].transform([category])[0]
        ]
        prediction = rf_model.predict([encoded_input])
        recommended_products = df[df["Product"] == prediction[0]]["Product"].values[:3]
        return recommended_products
    except ValueError:
        return ["No matching product found. Please check input values."]

# Load models
rf_model, label_encoders, df_recommendation, skin_types, concerns, categories = load_and_train_model(recommendation_file_path)

# User Choice
print("\n **Select an option:**")
print("1Ô∏è‚É£ Ingredient Analyzer")
print("2Ô∏è‚É£ Product Recommendation")
choice = input("Enter choice (1 or 2): ").strip()

if choice == "1":
    scanner = IngredientScanner(ingredient_csv_path)
    user_input = input("Upload image (enter path) or enter ingredients manually? (image/manual): ").strip().lower()

    if user_input == "image":
        image_path = input("Enter image path: ")
        scanner.convert_image_to_text(image_path)
    elif user_input == "manual":
        manual_input = input("Enter ingredients (comma-separated): ")
        scanner.preprocess(manual_input.split(','))

    scanner.analyze()
    scanner.report()

elif choice == "2":
    skin_type = input(f"Enter skin type {skin_types}: ").strip().lower()
    concern = input(f"Enter concern {concerns}: ").strip().lower()
    category = input(f"Enter category {categories}: ").strip().lower()

    recommendations = recommend_products(skin_type, concern, category, rf_model, label_encoders, df_recommendation)
    print("\n‚ú® **Recommended Products:**")
    for product in recommendations:
        print(f"- {product}")

else:
    print("‚ùå Invalid choice. Please select 1 or 2.")